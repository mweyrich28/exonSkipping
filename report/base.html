<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Malte Weyrich" />
  <title>Genomorientierte Bioinformatik - Report ExonSkipping</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Genomorientierte Bioinformatik - Report ExonSkipping</h1>
<p class="author">Malte Weyrich</p>
<p class="date">2024-11-02</p>
</header>
<hr />
<p><strong>Exon Skipping Splicing Events</strong> (<em>ES-SE</em>) beschreiben, wie co- oder posttranslational, manche Exons eines Transkripts durch das SpleiÃŸosom herausgeschnitten oder Ã¼bersprungen werden, wÃ¤hrend in anderen Transkripten des selben Gens, diese weiterhin Teil der mRNA bleiben. Die <em>ES-SE</em> lassen sich anhand von <strong>Gene Transfer Format</strong> (<em>GTF</em>) Dateien, also Genom Annotations Dateien ablesen und analysieren. Im Folgenden wird ein Programm zur Erkennung von allen <em>ES-SE</em> innerhalb eines Genoms anhand seiner Logik, Laufzeit und Ergebnisse analysiert, wobei nur <em>ES-SE</em> berÃ¼cksichtigt werden, die protein-kodierende Transkripte betreffen. Das Programm wurde auf allen verfÃ¼gbaren <em>GTF</em>-Dateien in <em>/mnt/biosoft/praktikum/genprakt/gtfs/</em> ausgefÃ¼hrt. Der Source Code und alle dazugehÃ¶rigen Komponenten sind auf <a href="https://github.com/mweyrich28/exonSkipping">GitHub</a> zu finden.</p>
<hr />
<h1 id="sec:problem">ES-SE Definition</h1>
<p>In einem Gen kann jedes Transkript jeweils mehrere <em>ES-SE</em> haben. Ein <em>ES-SE</em> involviert immer jeweils mindestens eine <strong>Splice Variant</strong> (<em>SV</em>) und einen <strong>Wild Type</strong> (<em>WT</em>). Beide dieser Begriffe beziehen sich auf Transkripte eines Gens <span class="math inline"><em>G</em></span>. Ein <em>SV</em> ist ein Transkript <span class="math inline"><em>T</em><sub><em>S</em><em>V</em></sub></span>, welches ein Intron <span class="math inline"><em>I</em></span> mit Startposition <span class="math inline"><em>I</em><sub><em>S</em></sub></span> und Endposition <span class="math inline"><em>I</em><sub><em>E</em></sub></span> besitzt, was gleichzeitig bedeutet, dass es in <span class="math inline"><em>T</em><sub><em>S</em><em>V</em></sub></span> zwei Exons <span class="math inline"><em>A</em>,â€†<em>B</em></span> gibt, die <span class="math inline"><em>I</em></span> flankieren. Somit endet <span class="math inline"><em>A</em></span> bei <span class="math inline"><em>I</em><sub><em>S</em></sub>â€…âˆ’â€…1â€„=â€„<em>A</em><sub><em>E</em></sub></span> und <span class="math inline"><em>B</em></span> startet bei <span class="math inline"><em>I</em><sub><em>E</em></sub>â€…+â€…1â€„=â€„<em>B</em><sub><em>S</em></sub></span>. Zudem ist die Position <span class="math inline"><em>B</em><sub><em>p</em><em>o</em><em>s</em></sub>â€…âˆ’â€…<em>A</em><sub><em>p</em><em>o</em><em>s</em></sub>â€„=â€„1</span>, wobei sich <span class="math inline"><em>A</em><sub><em>p</em><em>o</em><em>s</em></sub></span> auf die Position von Exon <span class="math inline"><em>A</em></span> relativ gesehen zu allen anderen Exons von <span class="math inline"><em>T</em><sub><em>S</em><em>V</em></sub></span> bezieht. Ein <em>WT</em> wÃ¤re nun ein weiteres Transkript <span class="math inline"><em>T</em><sub><em>W</em><em>T</em></sub></span> des selben Gens <span class="math inline"><em>G</em></span>, welches ebenfalls zwei Exons <span class="math inline"><em>C</em>,â€†<em>D</em></span> besitzt mit <span class="math inline"><em>C</em><sub><em>p</em><em>o</em><em>s</em></sub>â€„&lt;â€„<em>D</em><sub><em>p</em><em>o</em><em>s</em></sub></span>, wobei <span class="math inline"><em>C</em><sub><em>E</em></sub>â€„=â€„<em>I</em><sub><em>S</em></sub>â€…âˆ’â€…1</span> und <span class="math inline"><em>D</em><sub><em>S</em></sub>â€„=â€„<em>I</em><sub><em>E</em></sub>â€…+â€…1</span>, jedoch gilt fÃ¼r <span class="math inline"><em>C</em>,â€†<em>D</em></span>: <span class="math inline"><em>D</em><sub><em>p</em><em>o</em><em>s</em></sub>â€…âˆ’â€…<em>C</em><sub><em>p</em><em>o</em><em>s</em></sub>â€„&gt;â€„1</span>. Dies bedeutet, dass die Exons von <span class="math inline"><em>T</em><sub><em>W</em><em>T</em></sub></span> zwischen <span class="math inline"><em>C</em></span> und <span class="math inline"><em>D</em></span> in <span class="math inline"><em>T</em><sub><em>S</em><em>V</em></sub></span> Ã¼bersprungen wurden. Es kann pro Event mehrere <em>SV</em>â€™s und <em>WT</em>â€™s geben.</p>
<h1 id="java-programm">Java Programm</h1>
<h2 id="sec:logik">Logik</h2>
<p>Der Workflow der <em>JAR</em> lÃ¤sst sich in drei Schritte Aufteilen:</p>
<ol>
<li><p><strong>Einlesen der <em>GTF</em>-Datei und Initialisierung der Datenstruktur</strong></p>
<p>Zum einlesen wird die <em>GTF</em>-Datei zuerst nach relevanten Zeilen gefiltert, denn fÃ¼r uns sind momentan nur Zeilen relevant, die in der 3. Spalte entweder <em>"exon"</em> oder <em>"CDS"</em> stehen haben. Hierbei wird vermieden, die Methode <em>String.split("\t")</em> zu verwenden. Stattdessen wird in einem <em>for loop</em> jedes Zeichen einzeln betrachtet. Dabei werden Zeilen die mit einem <em>"#"</em> anfangen direkt Ã¼bersprungen. FÃ¼r alle anderen Zeilen werden die Anzahl der <em>tabs</em> gezÃ¤hlt und nach dem zweiten <em>tab</em>, werden alle darauf folgenden Zeichen zu einem <em>String</em> zusammen konkateniert, bis der dritte <em>tab</em> erreicht wurde. Falls der entstandenen String <span class="math inline">â€„âˆˆâ€„{"exon","CDS"}</span>, wird die Zeile einer <em>ArrayList&lt;String&gt;</em> hinzugefÃ¼gt, ansonsten wird mit der nÃ¤chsten Zeile weiter gemacht. Diese Liste enthÃ¤lt am Ende alle relevanten Zeilen. Jede der relevanten Zeilen werden erst jetzt mit <em>String.split("\t")</em> in ein <em>String[] mainComponents</em> geschrieben. Die <em>attributeColumn</em> wird aus <em>mainComponents</em> extrahiert (auch als ein <em>String[]</em> Names <em>attributes</em>), indem man <em>mainComponents[mainComponents.length - 1]</em> am <em>";"</em> teilt.</p>
<p>Mit diesen zwei Komponenten pro Zeile wird als erstes die <em>gene_id</em> abgespeichert und Ã¼berprÃ¼ft, ob wir eine neue <em>gene_id</em> erreicht haben. Falls ja, wird ein neues Gen erstellt. FÃ¼r die darauf folgenden Zeilen wird Ã¼berprÃ¼ft, ob wir ein neues Transkript erreicht haben. Neue Transkripte werden in einer <em>ArrayList&lt;Transkript&gt;</em> des dazugehÃ¶rigen Gens abgespeichert. Transkripte wiederum besitzen eine <em>ArrayList&lt;CodingDnaSequence&gt; cdsList</em> und zwei <em>HashMap&lt;Integer, CodingDnaSequence&gt;</em> <em>cdsStartIndices</em>, <em>cdsEndIndices</em>. FÃ¼r jede erstellte <em>CodingDnaSequence</em> eines Transkripts wird ein neuer Eintrag in den zwei <em>HashMap</em>â€™s gemacht, wobei jeweils eine der Koordinaten als SchlÃ¼ssel dient und auf das so eben erstellte Objekt abbildet. Zudem wird mit einer ZÃ¤hlvariable <em>int cdsCount</em> die Position der <em>CodingDnaSequence</em>â€™s innerhalb des Transkripts in dem <em>CodingDnaSequence</em> Objekt gespeichert. Wird ein neues Transkript erreicht, wird der <em>cdsCount</em> wieder zurÃ¼ckgesetzt.</p></li>
<li><p><strong>Generieren der <em>ES-SE</em></strong></p>
<p>Zum generieren der <em>ES-SE</em> werden als erstes fÃ¼r alle in dem Genom abgespeicherten Gene, die dazugehÃ¶rigen <em>Introns</em> errechnet und in einem <em>HashSet&lt;Introns&gt;</em> innerhalb des Gens abgespeichert. DafÃ¼r werden alle Transkripte eines Gens und deren <em>CodingDnaSequence</em>â€™s angeschaut. Die Introns werden dann mit jeweils zwei <em>CodingDnaSequence</em>â€™s berechnet (bei Genen die sich auf dem <em>"-"</em> Strang befinden, mÃ¼ssen zuerst die <em>cdsList</em>â€™s aller Transkripte invertiert werden und die Positionen der <em>CodingDnaSequence</em>â€™s neu berechnet werden. Das ist spÃ¤ter relevant fÃ¼r die Identifikation der <em>WT</em>â€™s):</p>
<pre><code>
// invert cdsList of transcripts
public void invertTranscripts() {
    for (int i = 0; i &lt; transcripts.size(); i++) {
        Transcript currTranscript = transcripts.get(i);
        currTranscript.reversCdsList();
        // updating pos attribute of each cds
        for (int j = 0; j &lt; currTranscript.getCdsList().size(); j++) {
            currTranscript.getCdsList().get(j).setPos(j);
        }
    }
}

// generating introns
for (Transcript transcript : transcripts) {
    for (int i = 0; i &lt; transcript.getCdsList().size() - 1; i++) {
        int intronStart = transcript.getCdsList().get(i).getEnd() + 1;
        int intronEnd = transcript.getCdsList().get(i + 1).getStart() - 1;
        Intron intron = new Intron(intronStart, intronEnd);
        introns.add(intron);
    }
}</code></pre>
<p>AnschlieÃŸend wird fÃ¼r jedes Gen <span class="math inline"><em>G</em></span> Ã¼ber die Intron Liste iteriert. FÃ¼r jedes Intron <span class="math inline"><em>I</em></span> mÃ¼ssen alle Transkripte von <span class="math inline"><em>G</em></span> nach <em>CodingDnaSequence</em>â€™s <span class="math inline"><em>A</em>,â€†<em>B</em></span> durchsucht werden, die die Bedingung <span class="math inline"><em>A</em><sub><em>E</em></sub>â€…+â€…1â€„=â€„<em>I</em><sub><em>S</em></sub></span> und <span class="math inline"><em>B</em><sub><em>S</em></sub>â€…âˆ’â€…1â€„=â€„<em>I</em><sub><em>E</em></sub></span>. Dies kann mit Hilfe der zwei <em>HashMap&lt;Integer, CodingDnaSequence&gt;</em> Objekte durchgefÃ¼hrt werden. Zudem wir fÃ¼r jedes Intron <span class="math inline"><em>I</em></span> jeweils 4 leere <em>HashSet&lt;String&gt;</em>â€™s erstellt:</p>
<ol>
<li><p><em>SV_INTORN</em>: enthÃ¤lt <em>"intronStart:intronEnd"</em> des momentanen Introns <span class="math inline"><em>I</em></span></p></li>
<li><p><em>SV_PROTS</em>: enthÃ¤lt die <em>proteinId</em> von <em>CodingDnaSequence</em> <span class="math inline"><em>A</em></span></p></li>
<li><p><em>WT_INTORN</em>: enthÃ¤lt alle <em>"intronStart:intronEnd"</em> Koordinaten, die zwischen <span class="math inline"><em>A</em></span> und <span class="math inline"><em>B</em></span> liegen</p></li>
<li><p><em>WT_PROTS</em>: enthÃ¤lt die <em>proteinId</em>â€™s von allen <em>CodingDnaSequence</em>â€™s die zwischen <span class="math inline"><em>A</em></span> und <span class="math inline"><em>B</em></span> liegen</p></li>
</ol>
<p>Nun gibt es zwei MÃ¶glichkeiten:</p>
<ol>
<li><p><span class="math inline"><em>A</em><sub><em>E</em></sub>â€…+â€…1â€„=â€„<em>I</em><sub><em>S</em></sub></span> und <span class="math inline"><em>B</em><sub><em>S</em></sub>â€…âˆ’â€…1â€„=â€„<em>I</em><sub><em>E</em></sub></span> und <span class="math inline"><em>B</em><sub><em>p</em><em>o</em><em>s</em></sub>â€…âˆ’â€…<em>A</em><sub><em>p</em><em>o</em><em>s</em></sub>â€„=â€„1</span></p></li>
<li><p><span class="math inline"><em>A</em><sub><em>E</em></sub>â€…+â€…1â€„=â€„<em>I</em><sub><em>S</em></sub></span> und <span class="math inline"><em>B</em><sub><em>S</em></sub>â€…âˆ’â€…1â€„=â€„<em>I</em><sub><em>E</em></sub></span> und <span class="math inline"><em>B</em><sub><em>p</em><em>o</em><em>s</em></sub>â€…âˆ’â€…<em>A</em><sub><em>p</em><em>o</em><em>s</em></sub>â€„&gt;â€„1</span></p></li>
</ol>
<p>Falls <span class="math inline"><em>i</em></span> eintrifft, handelt es sich um ein <em>SV</em> und es wird die <em>proteinId</em> von <em>CodingDnaSequence</em> <span class="math inline"><em>A</em></span> in <em>SV_PROTS</em> aufgenommen. Ansonsten werden bei Fall <span class="math inline"><em>i</em><em>i</em></span> alle <em>proteinId</em>â€™s der <em>CodingDnaSequence</em>â€™s zwischen <span class="math inline"><em>A</em></span> und <span class="math inline"><em>B</em></span> zu <em>WT_PROTS</em> und alle Introns zwischen <span class="math inline"><em>A</em></span> und <span class="math inline"><em>B</em></span> zu <em>WT_INTORN</em> hinzugefÃ¼gt. Dabei werden ebenfalls Werte wie <em>min/max_skipped_exon/bases</em> berechnet:</p>
<pre><code>// add all introns of WT to WT_INTRON and all cdsids/prot_ids to WT_prots
int skippedBases = 0;
for (int i = cdsFront.getPos() ; i &lt; cdsBehind.getPos(); i++) {
    int wtIntronStart = cdsList.get(i).getEnd() + 1;
    int wtIntronEnd = cdsList.get(i+1).getStart();
    WT_INTRON.add(wtIntronStart + &quot;:&quot; + wtIntronEnd);

    // like this i add many ids twice but that&#39;s fine :)
    WT_PROTS.add(cdsFront.getId());
    WT_PROTS.add(cdsBehind.getId());

    if (i &gt; cdsFront.getPos() &amp;&amp; i &lt; cdsBehind.getPos()) {
        // we are in a cds that was skipped
        // â†’ get end - start + 1 = length â†’ add to skipped bases
        skippedBases += cdsList.get(i).getEnd() 
                        - cdsList.get(i).getStart() + 1;
    }
}</code></pre>
<p>Ein <em>ES-SE</em> wird nur in die <em>ArrayList&lt;String&gt; events</em> aufgenommen, falls es fÃ¼r das momentane Intron <span class="math inline"><em>I</em></span> mindestens einen <em>WT</em> gab.</p></li>
<li><p><strong>Erstellen der <em>&lt;out&gt;.tsv</em> Datei</strong></p>
<p>Die <em>ArrayList&lt;String&gt; events</em> enthÃ¤lt nun alle <em>ES-SE</em> als <em>String</em> in bereits korrekter Formatierung. In einem <em>for loop</em> wird die LÃ¶sung Zeile fÃ¼r Zeile in ein <em>out.tsv</em> geschrieben.</p></li>
</ol>
<h2 id="laufzeit">Laufzeit</h2>
<p>Die Laufzeitanalyse wird in die drei Segmente aus <a href="#sec:logik" data-reference-type="ref" data-reference="sec:logik">2.1</a> unterteilt.</p>
<ol>
<li><p><strong>Einlesen der <em>GTF</em>-Datei und Initialisierung der Datenstruktur</strong></p>
<p>FÃ¼r eine <em>GTF</em>-Datei mit <span class="math inline"><em>m</em></span> Zeilen benÃ¶tigt die Selektion der relevanten Zeilen <span class="math inline"><em>n</em></span> schon mal mindestens <span class="math inline"><em>m</em></span> Vergleiche, da jede Zeile Ã¼berprÃ¼ft werden muss. FÃ¼r jede Zeile wird ein Substring ab dem zweiten <em>Tab</em> bis zum dritten <em>Tab</em> erstellt (auÃŸer bei Kommentaren, diese werden Ã¼bersprungen). Die Anzahl der Vergleiche pro Zeile ist kleiner als die LÃ¤nge der Zeile (da wir ab dem dritten <em>Tab</em> abbrechen) und lÃ¤sst sich als <span class="math inline"><em>a</em>â€„&lt;â€„<em>n</em>.<em>l</em><em>e</em><em>n</em><em>g</em><em>t</em><em>h</em></span> beschreiben. Also <br /><span class="math display">ğ’ª(<em>m</em>â€…â‹…â€…<em>a</em>)â€„âŸ¹â€„ğ’ª(<em>m</em>)</span><br /> ,da <span class="math inline"><em>a</em></span> eine Konstante ist.</p>
<p>Bei einer <em>GTF</em>-Datei mit <span class="math inline"><em>m</em></span> validen Zeilen (d.h. jede Zeile hat entweder einen <em>"exon"</em> oder <em>"CDS"</em> Eintrag) bleiben nach dem Filtern <span class="math inline"><em>m</em></span> Zeilen Ã¼brig. <strong>FÃ¼r jede dieser <span class="math inline"><em>m</em></span> Zeilen muss</strong>:</p>
<ol>
<li><p>Die Zeile am <em>Tab</em> geteilt werden: <br /><span class="math display">ğ’ª(<em>n</em>)</span><br /><span class="citation" data-cites="stackoverflow_split_complexity"></span> , wobei <span class="math inline"><em>n</em></span> die LÃ¤nge der Zeile ist.</p></li>
<li><p>Die letzte Komponente aus i. am <em>;</em> geteilt werden: lÃ¤sst sich ebenfalls mit <br /><span class="math display">ğ’ª(<em>n</em>)</span><br /> von oben beschrÃ¤nken.</p></li>
<li><p>Die <em>gene_id</em> aus den Attributen aus ii. mit <em>String parseAttributes(String[] attributeEntries, String attributeName)</em> abfragen, also: <br /><span class="math display">ğ’ª(<em>e</em>â€…â‹…â€…<em>e</em><sub><em>l</em></sub>)</span><br /> , wobei <span class="math inline"><em>e</em></span> die LÃ¤nge des <em>attributeEntries</em> Arrays ist und <span class="math inline"><em>e</em><sub><em>l</em></sub></span> die LÃ¤nge des lÃ¤ngsten Eintrags in <em>attributeEntries</em> ist, da wir im Worst Case Ã¼ber alle EintrÃ¤ge in <em>attributeEntries</em> iterieren (<span class="math inline"><em>e</em></span>) und fÃ¼r jeweils jeden Eintrag mindesten vier String Operationen (<em>trim()</em>, <em>indexOf()</em>, zwei mal <em>substring()</em>) und eine Vergleichsoperation (<em>equals()</em>) aufrufen, welche maximal <span class="math inline"><em>e</em><sub><em>l</em></sub></span> viele Operationen benÃ¶tigen. Also <span class="math inline">ğ’ª(<em>e</em>â€…â‹…â€…5â€…â‹…â€…<em>e</em><sub><em>l</em></sub>)â€„=â€„ğ’ª(<em>e</em>â€…â‹…â€…<em>e</em><sub><em>l</em></sub>)</span>. FÃ¼r jedes weitere Vorkommen von <em>parseAttributes()</em> wird diese KomplexitÃ¤t angenommen.</p></li>
<li><p>Ein neues Gen initialisiert werden und der <em>gene_name</em> abgefragt werden (falls ein neues Gen erreicht wurde), also: <br /><span class="math display">ğ’ª(1â€…+â€…<em>e</em>â€…â‹…â€…<em>e</em><sub><em>l</em></sub>)</span><br /></p></li>
<li><p>Die <em>transcript_id</em> abgefragt werden, also <br /><span class="math display">ğ’ª(<em>e</em>â€…â‹…â€…<em>e</em><sub><em>l</em></sub>)</span><br /></p></li>
<li><p>Falls es sich um einen <em>"CDS"</em> Eintrag handelt, muss die <em>protein_id</em> abgefragt werden, also: <br /><span class="math display">ğ’ª(<em>e</em>â€…â‹…â€…<em>e</em><sub><em>l</em></sub>)</span><br /> und in Konstanter Zeit ggf. neue Objekte erstellt, oder auf bereits existierende Objekte zugreifen, um ein neues <em>CodingDnaSequence</em> Objekt zu erstellen.</p></li>
</ol>
<p>Insgesamt hat die Einleseroutine also eine KomplexitÃ¤t von <br /><span class="math display">(<em>A</em>)â€Šâ€ğ’ª(<em>m</em>â€…+â€…<em>m</em>â€…â‹…â€…(2â€…â‹…â€…<em>n</em>â€…â‹…â€…4â€…â‹…â€…(<em>e</em>â€…â‹…â€…<em>e</em><sub><em>l</em></sub>)))â€„=â€„ğ’ª(<em>m</em>â€…+â€…<em>m</em>â€…â‹…â€…<em>n</em>â€…â‹…â€…<em>e</em>â€…â‹…â€…<em>e</em><sub><em>l</em></sub>)â€„âˆˆâ€„ğ’ª(<em>m</em><sup>2</sup>).</span><br /> ,da <span class="math inline"><em>m</em>â€„&gt;â€„<em>n</em>â€„&gt;â€„<em>e</em><sub><em>l</em></sub>â€„&gt;â€„â€„=â€„<em>e</em></span> und somit <span class="math inline">ğ’ª(<em>m</em><sup>2</sup>)</span> eine valide obere Schranke darstellt.</p></li>
<li><p><strong>Generieren der <em>ES-SE</em></strong></p>
<p>Sei <span class="math inline"><em>g</em></span> die Anzahl an Genen in unserem Genom. Da wir vom Worst Case ausgehen sagen wir, dass sich jedes Gen auf dem <em>"-"</em> Strang befindet. So muss zuerst in jedem Transkript jedes Gens die <em>cdsList</em> invertiert werden. Dies geschieht in: <br /><span class="math display">ğ’ª(<em>g</em>â€…â‹…â€…<em>g</em><sub><em>t</em></sub>â€…â‹…â€…2â€…â‹…â€…<em>t</em><sub><em>c</em></sub>)â€„=â€„ğ’ª(<em>g</em>â€…â‹…â€…<em>g</em><sub><em>t</em></sub>â€…â‹…â€…<em>t</em><sub><em>c</em></sub>)</span><br /> , wobei <span class="math inline"><em>g</em><sub><em>t</em></sub></span> die grÃ¶ÃŸte Anzahl an Transkripten von <span class="math inline"><em>g</em></span> ist und <span class="math inline"><em>t</em><sub><em>c</em></sub></span> die lÃ¤ngste <em>cdsList</em> eines Transkripts ist. Die Konstante <span class="math inline">2</span> kommt zustande, da zuerst die <em>cdsList</em> mit <em>Collections.reverse()</em> umgekehrt wird (<span class="math inline">ğ’ª(<em>g</em><sub><em>t</em></sub>)</span>) und dann nochmals in <span class="math inline">ğ’ª(<em>g</em><sub><em>t</em></sub>)</span> durchlaufen wird, um die in den <em>CodingDnaSequence</em> Objekten gespeicherte Position anzupassen. Dann werden fÃ¼r jedes Gen <span class="math inline"><em>g</em></span> die Introns generiert. Dies geschieht ebenfalls in <br /><span class="math display">ğ’ª(<em>g</em>â€…â‹…â€…<em>g</em><sub><em>t</em></sub>â€…â‹…â€…<em>t</em><sub><em>c</em></sub>)</span><br /> Die <em>ES-SE</em> werden in der <em>getEvents()</em> Methode berechnet. DafÃ¼r mÃ¼ssen fÃ¼r alle Gene alle Introns und alle Transkripte Ã¼berprÃ¼ft werden. Also schon mal <span class="math inline">ğ’ª(<em>g</em>â€…â‹…â€…<em>g</em><sub><em>i</em></sub>â€…â‹…â€…<em>g</em><sub><em>t</em></sub>)</span>. Hier ist <span class="math inline"><em>g</em><sub><em>i</em></sub></span> die grÃ¶ÃŸte Anzahl an Introns von allen Genen und <span class="math inline"><em>g</em><sub><em>t</em></sub></span> wieder die grÃ¶ÃŸte Anzahl an Transkripten aller Gene. Alle anderen Operationen sind konstant in ihrer KomplexitÃ¤t, da bei ihnen lediglich bereits existente Werte in <em>HashMaps</em> oder Objekten abgefragt werden. Nur falls ein <em>WT</em> entdeckt wird, wird in einem <em>for loop</em> Ã¼ber die <em>CodingDnaSequence</em>â€™s zwischen <span class="math inline"><em>C</em></span> und <span class="math inline"><em>D</em></span> (siehe <a href="#sec:problem" data-reference-type="ref" data-reference="sec:problem">1</a>. ES-SE Definition) iteriert. Sei <span class="math inline"><em>m</em><em>S</em><em>E</em></span> (= maxSkippedExons) also die von allen <em>ES-SE</em> eines Genoms maximale Anzahl an Ã¼bersprungenen Exons, so wÃ¤re die gesamte KomplexitÃ¤t von (B): <br /><span class="math display">$$(B) \hspace{1em} \mathcal{O}(2 \cdot (g \cdot g_{t} \cdot t_{c}) + g \cdot g_{i} \cdot g_{t} \cdot mSE) = \mathcal{O}(g \cdot g_{t} \cdot t_{c} + g \cdot g_{i} \cdot g_{t} \cdot mSE)$$</span><br /></p></li>
<li><p><strong>Erstellen der <em>&lt;out&gt;.tsv</em> Datei</strong></p>
<p>Hat eine KomplexitÃ¤t von <br /><span class="math display">(<em>C</em>)â€Šâ€ğ’ª(<em>E</em>)</span><br /> , wenn <span class="math inline"><em>E</em></span> die Menge aller <em>ES-SE</em> ist.</p></li>
</ol>
<p>Zusammenfassend also eine GesamtkomplexitÃ¤t von: <br /><span class="math display">(<em>A</em>)â€…+â€…(<em>B</em>)â€…+â€…(<em>C</em>)â€„=â€„ğ’ª(<em>m</em><sup>2</sup>â€…+â€…<em>g</em>â€…â‹…â€…<em>g</em><sub><em>t</em></sub>â€…â‹…â€…<em>t</em><sub><em>c</em></sub>â€…+â€…<em>g</em>â€…â‹…â€…<em>g</em><sub><em>i</em></sub>â€…â‹…â€…<em>g</em><sub><em>t</em></sub>â€…â‹…â€…<em>m</em><em>S</em><em>E</em>â€…+â€…<em>E</em>)â€„âˆˆâ€„ğ’ª(<em>m</em><sup>2</sup>)</span><br /> , da <span class="math inline"><em>m</em><sup>2</sup>â€„&gt;â€„<em>g</em>â€…â‹…â€…<em>g</em><sub><em>t</em></sub>â€…â‹…â€…<em>t</em><sub><em>c</em></sub></span> und <span class="math inline"><em>m</em><sup>2</sup>â€„&gt;â€„<em>g</em>â€…â‹…â€…<em>g</em><sub><em>i</em></sub>â€…â‹…â€…<em>g</em><sub><em>t</em></sub>â€…â‹…â€…<em>m</em><em>S</em><em>E</em>â€…+â€…<em>E</em></span>. Das bedeutet, dass die Kosten der Gesamtoperation im Wesentlichen durch das Einlesen und Strukturieren der Daten (Teil A) dominiert werden, wenn man davon ausgeht, dass <span class="math inline"><em>m</em></span> in der Praxis grÃ¶ÃŸer als <span class="math inline"><em>g</em></span>, <span class="math inline"><em>g</em><sub><em>t</em></sub></span>, <span class="math inline"><em>t</em><sub><em>c</em></sub></span>, <span class="math inline"><em>g</em><sub><em>i</em></sub></span> und <span class="math inline"><em>m</em><em>S</em><em>E</em></span> ist.</p>
<h2 id="korrektheit">Korrektheit</h2>
<p>In der Einleseroutine werden alle relevanten Zeilen verarbeitet und das Genom korrekt Initialisiert, sofern die Struktur von dem <em>GTF</em> den <a href="https://asia.ensembl.org/info/website/upload/gff.html">offiziellen Konventionen</a> folgt und die jeweiligen <em>CodingDnaSequence</em>â€™s in korrekter Reihenfolge (je nach <em>"-"/"+"</em> Strang) vorliegen. Zudem werden, falls es keine <em>"protein_id"</em> fÃ¼r eine gegebene Zeile gibt, nach der <em>"ccdsid"</em> gesucht und falls es diese nicht gibt, wird die <em>"protein_id"</em> mit <em>"NaN"</em> Ã¼berschrieben. So werden alle Zeilen, die <em>"CDS"</em> in ihrer dritten Spalte stehen haben, genutzt, um das Genom aufzufÃ¼llen. FÃ¼r das Errechnen der <em>ES-SE</em> in Schritt (B) gilt folgendes: Alle mÃ¶glichen Introns in einem Gen werden Ã¼berprÃ¼ft und fÃ¼r jedes Intron werden alle Transkripte des jeweiligen Gens auf bei <span class="math inline"><em>I</em><sub><em>S</em></sub>â€…âˆ’â€…1</span> endende und bei <span class="math inline"><em>I</em><sub><em>E</em></sub>â€…+â€…1</span> startende <em>CodingDnaSequence</em>â€™s <span class="math inline"><em>A</em>,â€†<em>B</em></span> abgefragt. FÃ¼r jeden <em>SV</em> oder <em>WT</em> Kandidaten wird anschlieÃŸend geschaut, ob es zwischen <span class="math inline"><em>A</em></span> und <span class="math inline"><em>B</em></span> weitere <em>CodingDnaSequence</em>â€™s gibt und je nach dem ein <em>ES-SE</em> entdeckt oder nicht. So ist das Programm unter der Annahme, dass die <em>GTF</em>-Datei fehlerfrei ist, korrekt.</p>
<h2 id="benchmarking">Benchmarking</h2>
<p>FÃ¼r das Benchmarking wird jeweils <em>/mnt/biosoft/praktikum/genprakt/gtfs/Homo_sapiens.GRCh38.86.gtf</em> verwendet, da sie die grÃ¶ÃŸte <em>GTF</em>-Datei mit <span class="math inline">1.4<em>G</em><em>B</em></span> ist. Die zwei <em>JARs</em> (<span class="math inline"><em>M</em></span> und <span class="math inline"><em>L</em></span>) aus unserer Gruppe wurden jeweils 30 Mal ausgefÃ¼hrt und davon dann ein Durchschnitt errechnet.</p>
<figure>
<img src="./plots/benchmark_time.jpg" id="fig:-plots-benchmark_time-jpg" style="width:80.0%" alt="" /><figcaption>Methoden Durchschnittslaufzeit der Schritte A, B, C in ms nach 30 facher AusfÃ¼hrung auf Hardware: <em>AMD Ryzen 7 PRO 4750U with Radeon Graphics (16) @ 1.700GHz</em></figcaption>
</figure>
<p>In Abbildung <a href="#fig:-plots-benchmark_time-jpg" data-reference-type="ref" data-reference="fig:-plots-benchmark_time-jpg">1</a> ist eindeutig zu sehen, wie das Einlesen und Initialisieren der Datenstruktur aus Schritt (A), die Dominante Komponente beider <em>JARs</em>, mit <span class="math inline">6721<em>m</em><em>s</em></span> und <span class="math inline">26977<em>m</em><em>s</em></span> bildet, wÃ¤hrend die Generierung der <em>ES-SE</em> lediglich <span class="math inline">262<em>m</em><em>s</em></span> und <span class="math inline">498<em>m</em><em>s</em></span> benÃ¶tigt. FÃ¼r die <em>Memory Allocations</em> wurde der in <em>IntelliJ</em> zur VerfÃ¼gung gestellter <em>Profiler</em> verwendet. Wichtig ist hierbei der Unterschied zwischen <em>RAM</em> und <em>Memory Allocations</em>: Der <em>Profiler</em> erfasst, wie viel Speicher ein Programm insgesamt anfordert, auch wenn ein GroÃŸteil davon spÃ¤ter wieder durch den <em>Garbage Collector</em> freigegeben wird. Der <em>Profiler</em> gibt also eher eine Obergrenze des Speicherverbrauchs an, nicht den exakten <em>RAM</em>-Verbrauch. Der Schritt (A) ist auch hier dominant und fordert in <em>JAR</em> <span class="math inline"><em>M</em></span> insgesamt <span class="math inline">10.33<em>G</em><em>B</em></span> an Speicher an. Von diesen <span class="math inline">10.33<em>G</em><em>B</em></span> werden alleine <span class="math inline">6.72<em>G</em><em>B</em></span> von der Methode <em>String.split()</em> gefordert. <em>JAR</em> <span class="math inline"><em>L</em></span> hingegen benÃ¶tigt <span class="math inline">65.32<em>G</em><em>B</em></span> an Memory Allocations, wobei der Hauptteil dieses Volumens (ca. <span class="math inline">60<em>G</em><em>B</em></span>) fÃ¼r die Methode <em>String.replaceAll()</em> aufgewendet wird. FÃ¼r die Berechnung der <em>ES-SE</em> werden lediglich <span class="math inline">288.11<em>M</em><em>B</em></span> (<span class="math inline"><em>M</em></span>) und <span class="math inline">296.91<em>M</em><em>B</em></span> (<span class="math inline"><em>L</em></span>) in Anspruch genommen. Die starken Diskrepanzen in Schritt (A) liegen daran, dass die <em>JAR</em> <span class="math inline"><em>L</em></span> alle Zeilen mit dem <em>Parser</em> einlieÃŸt und von diesen jedes mal die <em>attributes</em> vollstÃ¤ndig in einer Datenstruktur abspeichert. Die Methode, die die <em>attributes</em> in <span class="math inline"><em>L</em></span> verarbeitet, ruft fÃ¼r jedes Attribut-Paar (<em>key</em>, <em>val</em>), die Methode <em>String.replaceAll("\"")</em> auf, welche teuer in Laufzeit und <em>Memory Allocations</em> ist. Da es in <em>/mnt/biosoft/praktikum/genprakt/gtfs/Homo_sapiens.GRCh38.86.gtf</em> insgesamt 2.575.498 EintrÃ¤ge gibt und pro Entrag jeweils mehrere Attribute, wird <em>String.replaceAll()</em> extrem hÃ¤ufig aufgerufen. ZusÃ¤tzlich werden die Attibute in <em>HashMap</em>â€™s gespeichert, was ein zusÃ¤tzlicher Faktor ist. In <em>JAR</em> <span class="math inline"><em>M</em></span> werden die Zeilen wie in <a href="#sec:logik" data-reference-type="ref" data-reference="sec:logik">2.1</a> beschreiben nur dann tatsÃ¤chlich bearbeitet, wenn sie einen <em>"exon"</em> oder <em>"CDS"</em> Eintrag beinhalten, zudem werden die <em>attributes</em> effizienter verarbeitet. Somit ist der <em>Parser</em> aus <span class="math inline"><em>M</em></span> zwar schneller, jedoch weniger versatil fÃ¼r andere Probleminstanzen.</p>
<h1 id="sec:res">Ergebnisse</h1>
<p>FÃ¼r die Analyse wurde die <em>GTF</em>-Datei <em>/mnt/biosoft/praktikum/genprakt/gtfs/Saccharomyces_cerevisiae.R64-1-1.75.gtf</em> ausgelassen, da es hier zu keinen <em>ES-SE</em> gekommen ist. Die Ursache dafÃ¼r ist wahrscheinlich, dass es, obwohl es in der Hefe auch zum SpleiÃŸen kommt, in der gegebenen <em>GTF</em>-Datei keine protein-kodierenden Transkripte mit Splicing gab. In der Hefe gibt es insgesamt sehr wenige Introns (ca. 300), verglichen mit (<span class="math inline">â€„&gt;â€„140.000</span>) in dem Menschen (<span class="citation" data-cites="doi:10.1073/pnas.0610354104"></span>), was die Abwesenheit von <em>ES-SE</em> in <em>Saccharomyces_cerevisiae.R64-1-1.75.gtf</em> zusÃ¤tzlich erklÃ¤rt. Die <em>GTF</em>-Dateien und die dazugehÃ¶rigen Ergebnisse werden ab jetzt mit den folgenden IDs aus Tabelle <a href="#tab:label" data-reference-type="ref" data-reference="tab:label">1</a> bezeichnet:</p>
<div id="tab:label">
<table>
<caption>Liste der verwendeten <em>GTF</em>-Dateien</caption>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>ID</strong></th>
<th style="text-align: left;"><strong><em>GTF</em>-Datei</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">h.ens.67</td>
<td style="text-align: left;">Homo_sapiens.GRCh37.67.gtf</td>
</tr>
<tr class="even">
<td style="text-align: left;">h.ens.75</td>
<td style="text-align: left;">Homo_sapiens.GRCh37.75.gtf</td>
</tr>
<tr class="odd">
<td style="text-align: left;">h.ens.86</td>
<td style="text-align: left;">Homo_sapiens.GRCh38.86.gtf</td>
</tr>
<tr class="even">
<td style="text-align: left;">h.ens.90</td>
<td style="text-align: left;">Homo_sapiens.GRCh38.90.gtf</td>
</tr>
<tr class="odd">
<td style="text-align: left;">h.ens.93</td>
<td style="text-align: left;">Homo_sapiens.GRCh38.93.gtf</td>
</tr>
<tr class="even">
<td style="text-align: left;">m.ens.75</td>
<td style="text-align: left;">Mus_musculus.GRCm38.75.gtf</td>
</tr>
<tr class="odd">
<td style="text-align: left;">h.gc.10</td>
<td style="text-align: left;">gencode.v10.annotation.gtf</td>
</tr>
<tr class="even">
<td style="text-align: left;">h.gc.25</td>
<td style="text-align: left;">gencode.v25.annotation.gtf</td>
</tr>
</tbody>
</table>
</div>
<p>Als erstes wird die Anzahl an aller protein-kodierenden Gene einer <em>GTF</em> mit der Anzahl an Genen mit <em>ES-SE</em> und der Gesamtanzahl an <em>ES-SE</em> verglichen:</p>
<figure>
<img src="./plots/genes.jpg" id="fig:-plots-genes-jpg" style="width:80.0%" alt="" /><figcaption>Vergleich zwischen Gene Gesamt, Gene mit <em>ES-SE</em> und <em>ES-SE</em> Gesamt pro <em>GTF</em></figcaption>
</figure>
<p>In Abbildung <a href="#fig:-plots-genes-jpg" data-reference-type="ref" data-reference="fig:-plots-genes-jpg">2</a> sieht man, wie die Anzahl an Genen in den verschiedenen <em>GTF</em>-Dateien des Menschen in einem Intervall von <span class="math inline">[20.320;â€†23.393]</span> variieren. Dies liegt daran, dass die <em>GTF</em>-Dateien jeweils von unterschiedlichen Assemblies und Annotations Versionen stammen, welche beide einen starken Einfluss auf die resultierende <em>GTF</em> haben (und somit auch auf das Ergebnis der <em>JAR</em>). Wie zu erwarten, hat bei den zum Menschen zugehÃ¶rigen <em>GTF</em>-Dateien, die mit den meisten Genen auch die meisten <em>ES-SE</em>. Die Dateien <em>"h.gc.25"</em>, <em><strong>"h.ens.67"</strong></em>, <em>"h.ens.86"</em>, <em>"h.ens.90"</em>, <em>"h.ens.93"</em> haben alle eine sehr Ã¤hnliche Verteilung der <em>"ES-SE Gesamt"</em> und <em>"Gene mit ES-SE"</em> Kategorie, obwohl die <em>GTF</em>-Datei von <em><strong>"h.ens.67"</strong></em> mehr Gene beinhaltet, als die <em>vier anderen</em> <em>GTF</em>-Dateien. <em>"h.gc.10"</em> scheint am wenigsten <em>Gene mit ES-SE</em> und <em>"ES-SE Gesamt"</em> zu besitzen. Bei der Maus wiederum gibt es vergleichsweise wenige <em>ES-SE</em>, obwohl es insgesamt fast genau so viele protein-kodierende Gene gibt (23.119) wie in <em>"h.ens.75"</em> (23.393).</p>
<p>Unter Einbezug der Abbildungen <a href="#fig:-plots-skipped_bases-jpg" data-reference-type="ref" data-reference="fig:-plots-skipped_bases-jpg">3</a> und <a href="#fig:-plots-skipped_exons-jpg" data-reference-type="ref" data-reference="fig:-plots-skipped_exons-jpg">4</a>, sind die selben Trends zu beobachten, die sich in Abbildung <a href="#fig:-plots-genes-jpg" data-reference-type="ref" data-reference="fig:-plots-genes-jpg">2</a> bereits andeuten:</p>
<figure>
<img src="./plots/skipped_bases.jpg" id="fig:-plots-skipped_bases-jpg" style="width:80.0%" alt="" /><figcaption>Kumulative Verteilung der Ã¼bersprungenen Basen pro <em>GTF</em></figcaption>
</figure>
<p>Abbildung <a href="#fig:-plots-skipped_bases-jpg" data-reference-type="ref" data-reference="fig:-plots-skipped_bases-jpg">3</a> zeigt die kumulative Verteilung der Ã¼bersprungenen Basen pro <em>GTF</em>. Alle Kurven zeigen einen charakteristischen S-fÃ¶rmigen Verlauf, was auf ein Ã¤hnliches grundlegendes Muster im <em>ES-SE</em> Verhalten hindeutet. Es bilden sich hauptsÃ¤chlich zwei Plateaus aus: Ein hÃ¶heres Plateau bei etwa 15.000-17.500 Ã¼bersprungenen Basen fÃ¼r die vom Mensch stammenden <em>GTF</em>-Dateien und ein niedrigeres Plateau bei etwa 6.000 Ã¼bersprungenen Basen fÃ¼r die Maus. Die zwei AusreiÃŸer (<em>"h.ens.75"</em> und <em>"h.gc.10"</em>) des hÃ¶heren Plateaus sind wieder auf die jeweils grÃ¶ÃŸte und kleinste Anzahl an Genen mit <em>ES-SE</em> innerhalb der Humanen <em>GTF</em>-Dateien zurÃ¼ckzufÃ¼hren.</p>
<p>Der steilste Anstieg der Kurven erfolgt im Bereich zwischen 100 und 1.000 Ã¼bersprungenen Basen, was darauf hindeutet, dass die meisten <em>ES-SE</em> in diesem GrÃ¶ÃŸenbereich stattfinden. Die logarithmische Skalierung der x-Achse verdeutlicht, dass die <em>ES-SE</em> Ã¼ber mehrere GrÃ¶ÃŸenordnungen hinweg auftreten, von einzelnen Basen bis hin zu mehreren tausend Basen.</p>
<figure>
<img src="./plots/skipped_exons.jpg" id="fig:-plots-skipped_exons-jpg" style="width:80.0%" alt="" /><figcaption>Kumulative Verteilung der Ã¼bersprungenen Exons pro <em>GTF</em></figcaption>
</figure>
<p>Abbildung <a href="#fig:-plots-skipped_exons-jpg" data-reference-type="ref" data-reference="fig:-plots-skipped_exons-jpg">4</a> zeigt die kumulative Verteilung der Ã¼bersprungenen Exons pro <em>GTF</em>. Die meisten <em>ES-SE</em> betreffen lediglich ein oder zwei Exons und werden mit zunehmender Anzahl an Ã¼bersprungenen Exons immer weniger. Diese Verteilung unterstreicht die biologische Relevanz von <em>Single-Exon-Skipping</em> als hÃ¤ufigstem Mechanismus im alternativen SpleiÃŸen und zeigt gleichzeitig, dass komplexere <em>ES-SE</em> mit mehreren Exons zwar vorkommen, aber deutlich seltener sind.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><em><strong>Symbol</strong></em></th>
<th style="text-align: left;"><em><strong>ID</strong></em></th>
<th style="text-align: left;"><em><strong>Basen</strong></em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">TTN</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000155657;r=2:178525989-178830802">ENSG00000155657</a></td>
<td style="text-align: left;">26.106</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ttn</strong></td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Mus_musculus/Gene/Summary?db=core;g=ENSMUSG00000051747;r=2:76534324-76812891"><strong>ENSMUSG00000051747</strong></a></td>
<td style="text-align: left;">24.843</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TTN</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Idhistory?g=ENSG00000283186">ENSG00000283186</a></td>
<td style="text-align: left;">22.134</td>
</tr>
<tr class="even">
<td style="text-align: left;">MUC4</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000145113;r=3:195746765-195811973">ENSG00000145113</a></td>
<td style="text-align: left;">12.875</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ADGRV1</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000164199;r=5:90529344-91164437">ENSG00000164199</a></td>
<td style="text-align: left;">12.530</td>
</tr>
<tr class="even">
<td style="text-align: left;">DYNC2H1</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000187240;r=11:103109410-103479863">ENSG00000187240</a></td>
<td style="text-align: left;">10.182</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Fsip2</strong></td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Mus_musculus/Gene/Summary?db=core;g=ENSMUSG00000075249;r=2:82773978-82839281"><strong>ENSMUSG00000075249</strong></a></td>
<td style="text-align: left;">9.659</td>
</tr>
<tr class="even">
<td style="text-align: left;">NBPF20</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Idhistory?g=ENSG00000203832">ENSG00000203832</a></td>
<td style="text-align: left;">9.573</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FSIP2</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000188738;r=2:185738804-185833290">ENSG00000188738</a></td>
<td style="text-align: left;">9.437</td>
</tr>
<tr class="even">
<td style="text-align: left;">XIRP2</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000163092;r=2:166888480-167259753">ENSG00000163092</a></td>
<td style="text-align: left;">9.379</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><em><strong>Symbol</strong></em></th>
<th style="text-align: left;"><em><strong>ID</strong></em></th>
<th style="text-align: left;"><em><strong>Exons</strong></em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">TTN</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000155657;r=2:178525989-178830802">ENSG00000155657</a></td>
<td style="text-align: left;">169</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Ttn</strong></td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Mus_musculus/Gene/Summary?db=core;g=ENSMUSG00000051747;r=2:76534324-76812891"><strong>ENSMUSG00000051747</strong></a></td>
<td style="text-align: left;">154</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TTN</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Idhistory?g=ENSG00000283186">ENSG00000283186</a></td>
<td style="text-align: left;">121</td>
</tr>
<tr class="even">
<td style="text-align: left;">NBPF20</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Idhistory?g=ENSG00000203832">ENSG00000203832.5</a></td>
<td style="text-align: left;">78</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DYNC2H1</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000187240;r=11:103109410-103479863">ENSG00000187240</a></td>
<td style="text-align: left;">70</td>
</tr>
<tr class="even">
<td style="text-align: left;">NBPF10</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000271425;r=1:146064711-146229000">ENSG00000271425</a></td>
<td style="text-align: left;">70</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NBPF10</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Idhistory?g=ENSG00000163386">ENSG00000163386</a></td>
<td style="text-align: left;">60</td>
</tr>
<tr class="even">
<td style="text-align: left;">ADGRV1</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000164199;r=5:90529344-91164437">ENSG00000164199</a></td>
<td style="text-align: left;">59</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NBPF20</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Summary?db=core;g=ENSG00000162825;r=1:145289900-145425603">ENSG00000162825</a></td>
<td style="text-align: left;">56</td>
</tr>
<tr class="even">
<td style="text-align: left;">NBPF12</td>
<td style="text-align: left;"><a href="https://asia.ensembl.org/Homo_sapiens/Gene/Idhistory?g=ENSG00000186275">ENSG00000186275</a></td>
<td style="text-align: left;">52</td>
</tr>
</tbody>
</table>
<p>Die Tabellen in Abbildung <a href="#tab:top" data-reference-type="ref" data-reference="tab:top">[tab:top]</a> zeigen die Top-10 Gene basierend auf der Anzahl ihrer Basen (links) und Exons (rechts). Bei Genen mit identischen Transkripten, die sich nur durch Suffix-Annotationen aus verschiedenen GTF-Dateien unterscheiden (z.B. <em>ENSG00000155657</em> und<br />
<em>ENSG00000155657.25</em>), wurde nur ein ReprÃ¤sentant beibehalten, da diese Duplikate biologisch dasselbe Gen reprÃ¤sentieren und sich lediglich in ihrer Versions-/Quellenkennzeichnung unterscheiden. Die RÃ¤nge in den Tabellen werden vor allem von Genen aus dem Menschen eingenommen, lediglich zwei Gene der <strong>Maus</strong> (<strong><em>"Ttn"</em></strong> und <strong><em>Fsip2</em></strong>) konkurrieren mit den anderen Genen der Rangliste. Dabei ist <em>"TTN"</em> in beiden Kategorien auf dem ersten Platz mit Ã¼ber 26000 Ã¼bersprungenen Basen und fast 170 Ã¼bersprungenen Exons. <em>"TTN"</em> und <strong><em>"Ttn"</em></strong> sind eng verwandte Gene, welche beide fÃ¼r das Protein <em>Titin</em> in den jeweiligen Organismen verantwortlich sind. <em>Titin</em> wiederum hat eine sehr wichtige Rolle in der Muskelkontraktion und dient zur Stabilisierung und FlexibilitÃ¤t der Sarkomere (<span class="citation" data-cites="uniprot_titin"></span>). Zudem sind <em>"TTN"</em> und <strong><em>"Ttn"</em></strong> jeweils mit 34.350 (<span class="citation" data-cites="uniprot_TTN"></span>) und 35.213 (<span class="citation" data-cites="uniprot_Ttn"></span>) extrem lange Proteine, was die hohe Position in der Rangliste erklÃ¤rt. Ebenfalls aus der Tabelle hervorgehend ist, dass eine hohe Anzahl an Ã¼bersprungenen Exons nicht unbedingt mit der Anzahl an Ã¼bersprungenen Basen zusammenhÃ¤ngen muss. WÃ¤hrend das Gen <em>"MUC4"</em> mit 12.875 Basen auf Rang vier der linken Tabelle steht, fehlt in der rechten Tabelle von ihm jede Spur. In den Tabellen ist auch auffÃ¤llig, dass es oft das gleiche <strong><em>Gen Symbol</em></strong> mit unterschiedlicher <em><strong>ID</strong></em> und Werten gibt. Zum Beispiel ist <em>"TTN"</em> in beiden Tabellen jeweils zwei mal mit unterschiedlichen Werten gelistet. Diese Unterschiede entstehen durch die Verwendung von sechs verschiedenen <em>GTF</em>-Dateien fÃ¼r das menschliche Genom, die unterschiedliche Versionen und QualitÃ¤tsstufen der Genom Annotation reprÃ¤sentieren. So kann ein Gen wie <em>"TTN"</em> in einer neueren oder detaillierteren <em>GTF</em>-Datei mehr annotierte Exons oder eine prÃ¤zisere Basenzahl aufweisen als in einer Ã¤lteren oder weniger umfassenden Annotation.</p>
<p>Â </p>
</body>
</html>
